const bucket = 'whitehairpin'
const url = `http://${bucket}.oss-cn-beijing.aliyuncs.com`
export const dns = `http://${bucket}.img-cn-beijing.aliyuncs.com`

export function get(key, { responseType, progress } = {}) {
  return new Promise(resolve => {

    var xhr = new XMLHttpRequest()
    xhr.open('GET', `${url}/${key}`)
    xhr.responseType = responseType ? responseType : 'arraybuffer'

    if (progress) xhr.onprogress = (e) => {
      if (e.lengthComputable) progress.style.width = e.loaded / e.total * 100 + '%'
    }

    xhr.onload = () => {
      resolve(xhr.response)
    }

    xhr.send(null)
  })
}

export function upload(key, data, { progress } = {}) {
  return new Promise(resolve => {
    form(key, data).then(out => {
      var xhr = new XMLHttpRequest()
      xhr.open('POST', url)

      if (progress) xhr.upload.onprogress = (e) => {
        if (e.lengthComputable) progress.style.width = (e.loaded === e.total) ? 0 : e.loaded / e.total * 100 + '%'
      }

      xhr.onload = () => {
        resolve(xhr.response)
      }

      xhr.send(out)
    })
  })
}

// type: file.type?
export function form(key, data) {
  const user = JSON.parse(localStorage.user)
  const AK = user.AK
  const SK = user.SK

  var cache = 'no-cache'
  if (key.match('img/') !== null) {
    cache = 'public,max-age=8640000'
  }

  const policyJson = {
    'expiration': (new Date(Date.now() + 3600000)).toJSON(),
    'conditions': [
      { bucket },
      // { 'acl': 'public-read' },
      { 'Content-Type': 'application/octet-stream' },
      { 'Cache-Control': cache },
      ['eq', '$key', key],
    ],
  }
  const policy = btoa(JSON.stringify(policyJson))

  return new Promise(resolve => {
    b64HmacSHA1(SK, policy).then(signature => {
      const formData = new FormData()
      formData.append('key', key)
      formData.append('x-oss-object-acl', 'public-read')
      formData.append('Content-Type', 'application/octet-stream')
      formData.append('Cache-Control', cache)
      formData.append('OSSAccessKeyId', AK)
      formData.append('policy', policy)
      formData.append('signature', signature)

      // 文件或文本内容，必须是表单中的最后一个域。
      formData.append('file', new Blob([data]))
      resolve(formData)
    })
  })
}


export function arrayBufferToStr(buf) {
  return String.fromCharCode.apply(null, new Uint16Array(buf))
}
export function strToArrayBuffer(str) {
  // return Uint16Array.from([...str], s => s.charCodeAt(0)).buffer
  // return new Uint16Array([...str].map(s => s.charCodeAt(0))).buffer
  return new TextEncoder('utf-16').encode(str)
}

//
// WebCryptoAPI
//
export function encStr(item) {
  return new Promise(resolve => {
    var user = JSON.parse(localStorage.user)
    var buf = strToArrayBuffer(item.text)
    encrypt(user.passwd, buf).then(data => {
      var x = {
        id: item.id,
        img: item.img,
        lastChange: item.lastChange
      }
      var b = strToArrayBuffer(JSON.stringify(x))
      var c = set(new Uint16Array([b.byteLength/2]).buffer, b)
      var out = set(c, data)
      resolve(out)
    })
  })
}

export function decStr(data) {
  return new Promise(resolve => {
    var x = new Uint16Array(data)
    var len = x.subarray(0, 1)[0]
    var str = String.fromCharCode.apply(null, x.subarray(1, len + 1))
    var item = JSON.parse(str)
    if (localStorage.user) {
      let user = JSON.parse(localStorage.user)
      let buf = data.slice((len + 1) * 2)
      decrypt(user.passwd, buf).then(out => {
        item.text = arrayBufferToStr(out)
        resolve(item)
      })
    } else {
      item.text = ''
      resolve(item)
    }
  })
}

// concat arrayBuffer
function set(a, b) {
  var out = new Uint8Array(a.byteLength + b.byteLength)
  out.set(new Uint8Array(a))
  out.set(new Uint8Array(b), a.byteLength)
  return out.buffer
}

function importKey(passwd) {
  return new Promise((resolve, reject) => {
    window.crypto.subtle.importKey(
      'raw', // can be 'jwk' or 'raw'
      strToArrayBuffer(passwd),
      { // this is the algorithm options
        name: 'AES-GCM',
      },
      false, // whether the key is extractable (i.e. can be used in exportKey)
      ['encrypt', 'decrypt'] // can 'encrypt', 'decrypt', 'wrapKey', or 'unwrapKey'
    )
      .then(key => {
        // returns the symmetric key
        resolve(key)
      })
      .catch(err => {
        reject(err)
      })
  })
}

export function encrypt(passwd, data) {
  return new Promise((resolve, reject) => {
    importKey(passwd)
      .then(key => {

        var iv = window.crypto.getRandomValues(new Uint8Array(12))
        window.crypto.subtle.encrypt({
          name: 'AES-GCM',

          // Don't re-use initialization vectors! Always generate a new iv every time your encrypt!
          // Recommended to use 12 bytes length
          // where iv is an ArrayBuffer or an ArrayBufferView with 12 random bytes (these should be generated by RandomSource.getRandomValues()).
          iv
        },
          key, // from generateKey or importKey above
          data // ArrayBuffer of data you want to encrypt
        )
          .then(encrypted => {
            // returns an ArrayBuffer containing the encrypted data
            resolve(set(iv.buffer, encrypted))
          })
          .catch(err => {
            reject(err)
          })
      })
  })
}

export function decrypt(passwd, data) {
  return new Promise((resolve, reject) => {
    importKey(passwd)
      .then(key => {
        window.crypto.subtle.decrypt({
          name: 'AES-GCM',
          iv: data.slice(0, 12) // The initialization vector you used to encrypt
        },
          key, // from generateKey or importKey above
          data.slice(12) // ArrayBuffer of the data
        )
          .then(decrypted => {
            // returns an ArrayBuffer containing the decrypted data
            resolve(decrypted)
          })
          .catch(err => {
            reject(err)
          })
      })
  })
}

export function b64HmacSHA1(key, str) {
  var keyBuf = new TextEncoder('utf-8').encode(key)
  var buf = new TextEncoder('utf-8').encode(str)

  return new Promise(resolve => {
    var hmacSha1 = {name: 'hmac', hash: {name: 'sha-1'}}
    crypto.subtle.importKey('raw', keyBuf, hmacSha1, true, ['sign', 'verify']).then(out => {
      crypto.subtle.sign(hmacSha1, out, buf).then(result => {
        resolve(btoa(String.fromCharCode.apply(null, new Uint8Array(result))))
      })
    })
  })
}
